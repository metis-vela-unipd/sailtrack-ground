#!/usr/bin/env python3

import json
import logging
from configparser import ConfigParser
from datetime import timedelta

from dpath.util import new
from paho.mqtt.client import Client
from serial import Serial
from timeloop import Timeloop

# -------------------------- Configuration -------------------------- #

LORA_READ_FREQ_HZ = 10
LOG_PRINT_FREQ_HZ = 0.1

MQTT_CLIENT_ID = "sailtrack-lora2mqtt"
CONFIG_FILE_PATH = "/etc/sailtrack/sailtrack.conf"

LORA_SERIAL_PORT_NAME = "/dev/serial0"
LORA_METRICS = (
    ("sensor/gps0", "fixType"),
    ("sensor/gps0", "epoch"),
    ("sensor/gps0", "lon"),
    ("sensor/gps0", "lat"),
    ("sensor/gps0", "gSpeed"),
    ("sensor/gps0", "headMot"),
    ("sensor/imu0", "euler.x"),
    ("sensor/imu0", "euler.y"),
    ("sensor/imu0", "euler.z"),
)

LORA_JOB_INTERVAL_MS = 1000 / LORA_READ_FREQ_HZ
LOG_JOB_INTERVAL_MS = 1000 / LOG_PRINT_FREQ_HZ

# ------------------------------------------------------------------- #

packet = ""
published_messages = 0
received_packets = 0
discarded_packets = 0


def on_publish_callback(client, userdata, mid):
    global published_messages
    published_messages += 1


config = ConfigParser()
config.read(CONFIG_FILE_PATH)
mqtt = Client(MQTT_CLIENT_ID)
mqtt.username_pw_set(config["mqtt"]["username"], config["mqtt"]["password"])
mqtt.on_publish = on_publish_callback
mqtt.connect(config["mqtt"]["host"])
mqtt.loop_start()
tl = Timeloop()
formatter = logging.Formatter(config.get("log", "format", raw=True))
logging.getLogger("timeloop").handlers[0].setFormatter(formatter)
logger = logging.getLogger(MQTT_CLIENT_ID)
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
handler.setFormatter(formatter)
logger.addHandler(handler)
ser = Serial(LORA_SERIAL_PORT_NAME, timeout=0)


@tl.job(interval=timedelta(milliseconds=LORA_JOB_INTERVAL_MS))
def lora_job():
    global packet
    global received_packets
    global discarded_packets
    line = ser.readline()
    if not line:
        return
    packet += line.decode()
    if packet[-1] != "\n":
        return
    values = packet.split()
    packet = ""
    if len(values) != len(LORA_METRICS):
        discarded_packets += 1
        return
    received_packets += 1
    data = {}
    for i, value in enumerate(values):
        topic = LORA_METRICS[i][0]
        name = LORA_METRICS[i][1]
        if topic not in data:
            data[topic] = {}
        new(data[topic], name, eval(value), separator=".")
    for topic, obj in data.items():
        mqtt.publish(topic, json.dumps(obj))


@tl.job(interval=timedelta(milliseconds=LOG_JOB_INTERVAL_MS))
def log_job():
    logger.info(f"Published messages: {published_messages}, "
                f"Received packets: {received_packets}, "
                f"Discarded packets: {discarded_packets}")


tl.start(block=True)
